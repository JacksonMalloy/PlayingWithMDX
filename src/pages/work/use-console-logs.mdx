---
title: Hooks for Logging
path: /work/use-console-logs
date: 2020-11-28
tags: ["React", "React Hooks"]
published: false
featured: true
---

import styled from 'styled-components'
import Header from '../../components/header'

# Hooks for Logging

I've always had to work on clearing logs from my apps while prepping for launch.
Sometimes it can be as easy as a quick search and replace in VS Code. But sometimes,
you may find yourself wanting some of those logs in production. You may have reasons, like me,
where commenting out logs is not acceptable. Perhaps you want messages in prod warning the user.

What if there was a better way to use console.log around your app. A way where we don't have to
mass replace, comment out, be weary of, while developing in different stages of our app. What if we
*could* have the same logs in development, staging and production?

What if we wrote a custom hook?
I'll start from scratch.

```jsx:title=src/components/useConsoleLog.js
const useConsoleLog = () => {
    return {}
}
```
We'll take the basic shape of a custom hook,
which takes some parameter(s) and returns an object. What do we want this hook to return?
Well, console methods! So lets make a function for a few.

```jsx:title=src/components/useConsoleLog.js {3-17}
const useConsoleLog = () => {

    const log = () => {
        console.log()
    }

    const logInfo = () => {
        console.info()
    }

    const logError = () => {
        console.error()
    }

    const logWarn = () => {
        console.warn()
    }

    return { log, logInfo, logError, logWarn }
}
```

It's just missing some parameters now. But what do we want to pass to our hook?
Perhaps a message, the variable, anything else? Lets add those for now.

```jsx:title=src/components/useConsoleLog.js
const useConsoleLog = (variable, message = '') => {

    const log = (variable, message) => {
        console.log(message, { variable })
    }

    const logInfo = (variable, message) => {
        console.info(message, { variable })
    }

    const logError = (variable, message) => {
        console.error(message, { variable })
    }

    const logWarn = (variable, message) => {
        console.warn(message, { variable })
    }

    return { log, logInfo, logError, logWarn }
}
```

We could stop here. But this wasn't enough for me.
I want my logs to show depending on the environement.


```jsx:title=src/components/useConsoleLog.js {3-5}
const useConsoleLog = () => {
    const log = (variable, message) => {
        if(process.env.NODE_ENV === 'DEVELOPMENT') {
            console.log(message, { variable })
        }
    }

    const logInfo = (variable, message) => {
        if(process.env.NODE_ENV === 'DEVELOPMENT') {
            console.info(message, { variable })
        }
    }

    const logError = (variable, message) => {
        if(process.env.NODE_ENV === 'DEVELOPMENT') {
            console.error(message, { variable })
        }
    }

    const logWarn = (variable, message) => {
        if(process.env.NODE_ENV === 'DEVELOPMENT') {
            console.warn(message, { variable })
        }
    }

    return { log, logInfo, logError, logWarn }
}
```

Now we have granular control over how we display our logs in development, staging and production.
A smiple but useful little snippet that could save you time in the long run.

Here's how to use our new hook.

```jsx:title=src/components/useConsoleLog.js

const Component = (props) => {
    const [data, setData] = useState(null)
    const { log, logInfo, logError, logWarn } = useConsoleLog()

    const handleClick = (event) => {
        logInfo(event.target.value, 'clicked')
    }

    useEffect(() => {
        const fetch = async () => {
            try {
                const remoteData = await fetchingRemoteData()
                setData(remoteData)
                log(data, 'Fetched from API')

            } catch (error) {
                logError(error, 'Optional comment')
            }
        }

        fetch()
    }, [])

    return (
        <section>
            {logWarn(props, 'Logging props within JSX')}
            <div>This is how we useConsoleLogs</div>
            <button onClick={handleClick}>Click me!</button>
        </section>
    )
}

```

It takes a bit to get used to, especially since you lose the syntax highlighting for `console.log`.
Another thing I considered was returning a single function that takes an argument to change which log
is used. Could be something like this:

```jsx:title=src/components/useConsoleLog.js
const useConsoleLog = (variable, message = '', type = 'log') => {

    const log = (variable, message, type) => {
        switch(type) {
            case: 'log'
                console.log(message, { variable })
                break;
            case: 'warn'
                console.warn(message, { variable })
                break;
            case: 'error'
                console.error(message, { variable })
                break;
            case: 'info'
                console.info(message, { variable })
                break;
        }
    }

    return { log }
}
```

But now what if we don't want to just add a message to our hook?
That could be annoying to have to type `log(tacos, '', 'info')` everytime we want to log something.

There are a million different ways we could take this, but it's just a start and I wanted to keep it simple.

I hope you enjoyed my DevTalk.

Please throw me a follow on Twitter!