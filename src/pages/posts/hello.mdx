import styled from 'styled-components'
import Header from '../../components/header'
export const myVariable = 'Yay!'


# My Bloated Components with Apollo Client 3

> A discussion on cleaning up components that make use of Apollo Client's `useMutation` hook. 
 I found that by extracting the API service logic into a seperate folder, it's much easier to scale 
 components, read components, and understand their functionality. 


### Bloat in React

I love to write code in a single file. There's just something about it that screams "efficient & productive", until it's not. 
No matter what feature I'm building, my tendency is to write multi-component files until it starts to get messy. 
It's in this chaos that *real* developers are born.

Kidding. 

But it is a skill that is important to learn as a developer. Breaking large components, delegating function calls, moving things around. 
It's something that we all have to get use to. In my SAAS application, this is how I solved my bloat issue.

Take a look at this component that creates a menu. 
For brevity sake, I've skimmed the imports, removed styles and other form fields.


```jsx:title=src/components/CreateMenu.js
export const CreateMenu = ({ setIsOpen }) => {
  const [{ organizationId, image }, dispatch] = useContext(UserContext)
  const [addMenu, { data }] = useMutation(ADD_MENU)

  const { values, errors, handleChange, handleSubmit } = useForm({
    onSubmit: ({ values }) => {
      const { menuTitle } = values

      addMenu({
        variables: { organization_id: organizationId, title: menuTitle },
        update: (store, { data }) => {
          const menuData = store.readQuery({
            query: MENUS_BY_ORGANIZATION,
            variables: { organization_id: organization_id },
          })

          store.writeQuery({
            query: MENUS_BY_ORGANIZATION,
            variables: { organization_id: organization_id },
            data: {
              menusByOrganization: [
                ...menuData.menusByOrganization,
                data.addMenu,
              ],
            },
          })
        },
      }).then(() => {
        dispatch(menuCreated())
        setIsOpen(false)
      })
    },
  })

  return (
    <form onSubmit={handleSubmit}>
      <Field
        id="menuTitle"
        name="menuTitle"
        required
        label="Menu Title"
        placeholder="Ex. Drink Menu"
        value={values.menuTitle}
        onChange={handleChange}
        type="text"
        error={errors.menuTitle}
      />
      <Button type="submit">
        Create
      </Button>
    </form>
  )
}

```

We are using a custom hook to handle the form
and utilizing the **update** function to update Apollo's cache once the item is added. 

There are a couple things wrong here that I would like to fix. 
1. I'm not using async await which might make this more readable
2. That update function is messy (although sometimes necessary to have full control of the cache)

In my case, I wanted to extract all service logic that was referencing my API in a **services** folder. 
This right here, was the culprit. 

```jsx:title=src/components/CreateMenu.js {9-31}
export const CreateMenu = ({ setIsOpen }) => {
  const [{ organizationId, image }, dispatch] = useContext(UserContext)
  const [addMenu, { data }] = useMutation(ADD_MENU)

  const { values, errors, handleChange, handleSubmit } = useForm({
    onSubmit: ({ values }) => {
      const { menuTitle } = values

      addMenu({
        variables: { organization_id: organizationId, title: menuTitle },
        update: (store, { data }) => {
          const menuData = store.readQuery({
            query: MENUS_BY_ORGANIZATION,
            variables: { organization_id: organization_id },
          })

          store.writeQuery({
            query: MENUS_BY_ORGANIZATION,
            variables: { organization_id: organization_id },
            data: {
              menusByOrganization: [
                ...menuData.menusByOrganization,
                data.addMenu,
              ],
            },
          })
        },
      }).then(() => {
        dispatch(menuCreated())
        setIsOpen(false)
      })
    },
  })

  return (
    <form onSubmit={handleSubmit}>
      <Field
        id="menuTitle"
        name="menuTitle"
        required
        label="Menu Title"
        placeholder="Ex. Drink Menu"
        value={values.menuTitle}
        onChange={handleChange}
        type="text"
        error={errors.menuTitle}
      />
      <Button type="submit">
        Create
      </Button>
    </form>
  )
}
```

What I did was take that service logic and extract it in its own file, and then import the function and pass the required parameters. 
I called this new function **handleCreateMenu** as it calls my API / resolver to tell my server to create a menu for the user.

This new function takes 2 arguments, the mutation from the `useMutation` hook, and an `args` object which contains
variables for the mutation and an organizationId for updating the cache. 


```js:title=src/services/menu.js
import { MENUS_BY_ORGANIZATION } from 'graphql/queries/menu/menusByOrganization'

export const handleCreateMenu = async (mutation, args) => {
  const { variables, organizationId } = args

  const data = await mutation({
    variables: variables,
    update: (store, { data }) => {
      const menuData: any = store.readQuery({
        query: MENUS_BY_ORGANIZATION,
        variables: { organization_id: organizationId },
      })

      store.writeQuery({
        query: MENUS_BY_ORGANIZATION,
        variables: { organization_id: organizationId },
        data: {
          menusByOrganization: [...menuData.menusByOrganization, data.addMenu],
        },
      })
    },
  })

  return data
}
```

Another good reason to do this is because now we only import `MENUS_BY_ORGANIZATION` in 
a single file where we want to call it. So now we can extract all other services such as `deleteMenu`, `editMenu`, `publishMenu`, etc... *as an example...*

This is how the useForm hook looks now. Much cleaner :)

```jsx:title=src/components/CreateMenu.js {6-14}
export const CreateMenu = ({ setIsOpen }) => {
  const [{ organizationId, image }, dispatch] = useContext(UserContext)
  const [addMenu, { data }] = useMutation(ADD_MENU)

  const { values, errors, handleChange, handleSubmit } = useForm({
    onSubmit: async ({ values }) => {
      const { menuTitle } = values
      const variables = { organization_id: organizationId, title: menuTitle }
      const args = { variables, organizationId }
      const data = await handleCreateMenu(addMenu, args).then(() => {
        dispatch(menuCreated())
        setIsOpen(false)
      })
    },
  })

  return (
    <form onSubmit={handleSubmit}>
      <Field
        id="menuTitle"
        name="menuTitle"
        required
        label="Menu Title"
        placeholder="Ex. Drink Menu"
        value={values.menuTitle}
        onChange={handleChange}
        type="text"
        error={errors.menuTitle}
      />
      <Button type="submit">
        Create
      </Button>
    </form>
  )
}
```

