---
title: Something
path: /posts/post
date: 2020-10-25
tags: ["Apollo Client", "React", "GraphQL"]
published: true
---

import styled from 'styled-components'
import Header from '../../components/header'

# Let me put hooks into context

So there's this new pattern arising, I'm sure many of you have heard.
Sometimes it can be a bit fishy (if you catch my drift), but mark my words
once you learn how to create your own, it will improve the experience you have
working with your codebase significantly.

>Lets take a look at `useContext`.

The `useContext` hook is a hook to provide a sort of "global store" as you might call it;
a global, single location to store state for a specific service, a particular function, similar logic.

Lets take a look at a simple use case of `useContext`

```jsx:title=src/components.js {}
import React, { createContext, useContext } from 'react'

const SomeContext = createContext();

export const Component = () => {
    return (
        <SomeContext.Provider value={"hello world"}>
            <ChildComponent/>
        </SomeContext.Provider>
    )

}

------------------------------------------------

export const ChildComponent = () => {
    return (
        <section>
            <GrandChildComponent />
        </section>
    )
}

------------------------------------------------

export const GrandChildComponent = () => {
    const value = useContext(SomeContext);

    return (
        <button onClick={() => console.log({ value })}>
            Click me
        </button>
    )
}

```
 What's happening here is that we're creating a store for state in a parent component.
 And **Sharing** that state with the children, grand children, great grandchildren and all
 the other generations of the family tree.

 This means that you can now access the prop `value="Hello World"` from anywhere within the component tree,
 just by calling useContext!

Prop drilling can become a real problem and using context can save you from prop drill hell.

But what's the use of passing through just a single prop.
What if we want to share multiple values, multiple props through the same context.
What if we wanted to add methods to edit those values from anywhere within the children of our parent tree.

Lets start with something simple first.


```jsx:title=src/components.js {}
import React, { createContext, useContext } from 'react'

const SomeContext = createContext();

export const Component = () => {
    const [count, setCount] = useState(0)

    const values = { count, setCount }

    return (
        <SomeContext.Provider value={values}>
            <ChildComponent />
        </SomeContext.Provider>
    )

}

------------------------------------------------

export const ChildComponent = () => {
    return (
        <section>
            <GrandChildComponent />
        </section>
    )
}

------------------------------------------------

export const GrandChildComponent = () => {
    const { count, setCount } = useContext(SomeContext);

    const increment = () => {
        setCount(count + 1)
    }

    const decrement = () => {
        setCount(count - 1)
    }

    return (
        <div>
            <span>{count}</span>
            <button onClick={increment}>
                decrement
            </button>
            <button onClick={decrement}>
                decrement
            </button>
        </div>
    )
}

```

Ok that was pretty easy! Just don't forget your imports if you're playing with this code.
What we're doing above is passing count and setCount through our component tree, letting all our
children components access the method / value without having to pass props through them.

Pretty neat!

Alright well now that we've gone through the simple example, lets take it a step further.
Lets use `useReducer` and pass its values through context!

```jsx:title=src/components.js {}
import React, { createContext, useContext, useReducer } from 'react'

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    default:
      throw new Error();
  }
}

const SomeContext = createContext();

export const Component = () => {
    const [state, dispatch] = useReducer(reducer, initialState);

    const values = [state, dispatch]

    return (
        <SomeContext.Provider value={values}>
            <ChildComponent />
        </SomeContext.Provider>
    )

}

------------------------------------------------

export const ChildComponent = () => {
    return (
        <section>
            <GrandChildComponent />
        </section>
    )
}

------------------------------------------------

export const GrandChildComponent = () => {
    const [state, dispatch] = useContext(SomeContext);

    const increment = () => {
        setCount(count + 1)
    }

    const decrement = () => {
        setCount(count - 1)
    }

    return (
        <div>
            <span>{count}</span>
            <button onClick={increment}>
                decrement
            </button>
            <button onClick={decrement}>
                decrement
            </button>
        </div>
    )
}

```


